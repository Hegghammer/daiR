#' Get document text from a Document AI response object
#'
#' This function extracts the text element of a json response object
#' returned from dai::dai_sync()
#'
#' @param object a json response object from DAI
#'
#' @return a string.
#' @export
#' @examples
#' \dontrun{
#' text <- text_from_dai_response(response)
#' }

text_from_dai_response <- function(object) {

  # checks
  if (is.list(object) && (inherits(object[[1]], "response"))) {
    stop("Input not recognized. Did you use dai_async instead of dai_sync?")
  }

  if (!(inherits(object, "response"))) {
    stop("Object is not a valid HTTP response.")
  }

  parsed <- httr::content(object, as="parsed")

  if (!("pages" %in% names(parsed))) {
    stop("Input not recognized. Is it from dai_async?")
  }

  if (!("text" %in% names(parsed))) {
    stop("DAI found no text. Was the page blank?")
  }

  # get text
  text <- parsed[["text"]]

  return(text)
}

#' Get document text from a Document AI json file
#'
#' This function extracts the text element of a json output file
#' generated by Google Document AI.
#'
#' @param file filepath of a json file from DAI
#'
#' @return a string.
#' @export
#' @examples
#' \dontrun{
#' text <- text_from_dai_file("output.json")
#' }

text_from_dai_file <- function(file) {

  # checks
  if (!(is.character(file) && length(file) == 1)) {
    stop("Invalid file input.")
  }

  if (!(is_json(file))){
    stop("Input file not .json. Is the file in your working directory?")
  }

  output <- jsonlite::fromJSON(file)

  if (!("pages" %in% names(output))) {
    stop("JSON not in right format. Is it from DAI?")
  }

  if (!("text" %in% names(output))) {
    stop("DAI found no text. Was the document blank?")
  }

  # get text
  text <- output$text

  return(text)
}

#' Inspect block bounding boxes in Google Document AI json output
#'
#' This function extracts the block bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the pdf source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#' @param dir path to output directory
#'
#' @details Not vectorized, but documents can be multi-page.
#' Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file
#' for each page in the original pdf. Assumes equal page length
#' between the pdf and the json, so if the json output was split
#' into shards, split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_blocks("pdf_page1.pdf", "pdf_output.json")
#' }

draw_blocks <- function(pdf,
                        json,
                        dir = tempdir()
                        ) {
  # checks
  if (length(pdf) > 1) {
    stop("Invalid pdf input. This function is not vectorised.")
  }

  if (length(json) > 1) {
    stop("Invalid json input. This function is not vectorised.")
  }

  if (!(is.character(pdf))) {
    stop("Invalid pdf input.")
  }

  if (!(is.character(json))) {
    stop("Invalid json input.")
  }

  if (!(is_pdf(pdf))){
    stop("Input 'pdf' not a pdf.")
  }

  if (!(is_json(json))){
    stop("Input 'json' not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of block boundary boxes
  pages_blocks <- output_as_list$pages$blocks

  pagewise_block_sets <- purrr::map(pages_blocks, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf),
                                    end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_block_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 3
                        )

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 2,
           col = "blue",
           family = "Liberation Sans"
           )

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_blocks.png")

    path <- file.path(dir, filename)

    magick::image_write(img, format = "png", path)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_blocks)

  message(glue::glue("Generated {pages} annotated image(s)."))
}

#' Inspect paragraph boxes in Google Document AI json output
#'
#' This function extracts the paragraph bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#' @param dir path to output directory
#'
#' @details Not vectorized, but documents can be multi-page.
#' Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file
#' for each page in the original pdf. Assumes equal page length
#' between the pdf and the json, so if the json output was split
#' into shards, split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_paragraphs("pdf_page1.pdf", "pdf_output.json")
#' }

draw_paragraphs <- function(pdf,
                            json,
                            dir = tempdir()
                            ) {
  # checks
  if (length(pdf) > 1) {
    stop("Invalid pdf input. This function is not vectorised.")
  }

  if (length(json) > 1) {
    stop("Invalid json input. This function is not vectorised.")
  }

  if (!(is.character(pdf))) {
    stop("Invalid pdf input.")
  }

  if (!(is.character(json))) {
    stop("Invalid json input.")
  }

  if (!(is_pdf(pdf))){
    stop("Input 'pdf' not a pdf.")
  }

  if (!(is_json(json))){
    stop("Input 'json' not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of token boundary boxes
  pages_paras <- output_as_list$pages$paragraphs

  pagewise_para_sets <- purrr::map(pages_paras, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf), end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_para_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 0.8)

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 0.6,
           col = "blue",
           family = "Liberation Sans"
           )

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_paragraphs.png")

    path <- file.path(dir, filename)

    magick::image_write(img, format = "png", path)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_paras)

  message(glue::glue("Generated {pages} annotated image(s)."))
}

#' Inspect line bounding boxes in Google Document AI json output
#'
#' This function extracts the line bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#' @param dir path to output directory
#'
#' @details Not vectorized, but documents can be multi-page.
#' Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file
#' for each page in the original pdf. Assumes equal page length
#' between the pdf and the json, so if the json output was split
#' into shards, split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_lines("pdf_page1.pdf", "pdf_output.json")
#' }

draw_lines <- function(pdf,
                       json,
                       dir = tempdir()
                       ) {

  # checks
  if (length(pdf) > 1) {
    stop("Invalid pdf input. This function is not vectorised.")
  }

  if (length(json) > 1) {
    stop("Invalid json input. This function is not vectorised.")
  }

  if (!(is.character(pdf))) {
    stop("Invalid pdf input.")
  }

  if (!(is.character(json))) {
    stop("Invalid json input.")
  }

  if (!(is_pdf(pdf))){
    stop("Input 'pdf' not a pdf.")
  }

  if (!(is_json(json))){
    stop("Input 'json' not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of token boundary boxes
  pages_lines <- output_as_list$pages$lines

  pagewise_line_sets <- purrr::map(pages_lines, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf),
                                    end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_line_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 0.8)

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 0.6,
           col = "blue",
           family = "Liberation Sans"
           )

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_lines.png")

    path <- file.path(dir, filename)

    magick::image_write(img, format = "png", path)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_lines)

  message(glue::glue("Generated {pages} annotated image(s)."))
}

#' Inspect token bounding boxes in Google Document AI json output
#'
#' This function extracts the token bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#' @param dir path to output directory
#'
#' @details Not vectorized, but documents can be multi-page.
#' Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file
#' for each page in the original pdf. Assumes equal page length
#' between the pdf and the json, so if the json output was split
#' into shards, split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_tokens("pdf_page1.pdf", "pdf_output.json")
#' }

draw_tokens <- function(pdf,
                        json,
                        dir = tempdir()
                        ) {

  # checks
  if (length(pdf) > 1) {
    stop("Invalid pdf input. This function is not vectorised.")
  }

  if (length(json) > 1) {
    stop("Invalid json input. This function is not vectorised.")
  }

  if (!(is.character(pdf))) {
    stop("Invalid pdf input.")
  }

  if (!(is.character(json))) {
    stop("Invalid json input.")
  }

  if (!(is_pdf(pdf))){
    stop("Input 'pdf' not a pdf.")
  }

  if (!(is_json(json))){
    stop("Input 'json' not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of token boundary boxes
  pages_tokens <- output_as_list$pages$tokens

  pagewise_token_sets <- purrr::map(pages_tokens, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf), end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_token_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 0.8)

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 0.6,
           col = "blue",
           family = "Liberation Sans"
           )

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_tokens.png")

    path <- file.path(dir, filename)

    magick::image_write(img, format = "png", path)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_tokens)

  message(glue::glue("Generated {pages} annotated image(s)."))
}
