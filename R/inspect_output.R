#' Get document text from a Document AI response object
#'
#' This function extracts the text element of a json response object
#' returned from dai::dai_sync()
#'
#' @param object a json response object
#'
#' @return a string.
#' @export
#' @examples
#' \dontrun{
#' text <- text_from_dai_response(response)
#' }

text_from_dai_response <- function(object) {

  json <- httr::content(object, as="parsed")

  text <- json[["text"]]

  return(text)
}

#' Get document text from a Document AI json file
#'
#' This function extracts the text element of a json output file
#' generated by Google Document AI.
#'
#' @param json filepath of the json file.
#'
#' @return a string.
#' @export
#' @examples
#' \dontrun{
#' text <- text_from_dai_file("output.json")
#' }

text_from_dai_file <- function(json) {

  if (!(grepl(".json$", json))){
    stop("Error: input file not .json.")
  }

  output <- jsonlite::fromJSON(json)

  text <- output$text

  return(text)
}

#' Inspect block bounding boxes in Google Document AI json output
#'
#' This function extracts the block bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the pdf source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#'
#' @details Not vectorized. Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file for each page in the original pdf.
#' Assumes equal page length between the pdf and the json, so if the json output was split into shards,
#' split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_blocks("pdf_page1.pdf", "pdf_output.json")
#' }

draw_blocks <- function(pdf,
                        json
                        ) {

  if (!(grepl(".pdf$", pdf))){
    stop("Error: input file not a pdf.")
  }

  if (!(grepl(".json$", json))){
    stop("Error: input file not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of block boundary boxes
  pages_blocks <- output_as_list$pages$blocks

  pagewise_block_sets <- purrr::map(pages_blocks, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf),
                                    end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_block_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 3
                        )

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 2,
           col = "blue"
           )

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_blocks.png")

    magick::image_write(img, format = "png", filename)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_blocks)

  print(glue::glue("Generated {pages} annotated image(s)."))
}

#' Inspect paragraph boxes in Google Document AI json output
#'
#' This function extracts the paragraph bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#'
#' @details Not vectorized. Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file for each page in the original pdf.
#' Assumes equal page length between the pdf and the json, so if the json output was split into shards,
#' split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_paragraphs("pdf_page1.pdf", "pdf_output.json")
#' }

draw_paragraphs <- function(pdf,
                            json
                            ) {

  if (!(grepl(".pdf$", pdf))){
    stop("Error: input file not a pdf.")
  }

  if (!(grepl(".json$", json))){
    stop("Error: input file not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of token boundary boxes
  pages_paras <- output_as_list$pages$paragraphs

  pagewise_para_sets <- purrr::map(pages_paras, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf), end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_para_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 0.8)

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 0.6,
           col = "blue")

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_paragraphs.png")

    magick::image_write(img, format = "png", filename)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_paras)

  print(glue::glue("Generated {pages} annotated image(s)."))
}

#' Inspect line bounding boxes in Google Document AI json output
#'
#' This function extracts the line bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#'
#' @details Not vectorized. Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file for each page in the original pdf.
#' Assumes equal page length between the pdf and the json, so if the json output was split into shards,
#' split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_lines("pdf_page1.pdf", "pdf_output.json")
#' }

draw_lines <- function(pdf,
                       json
                       ) {

  if (!(grepl(".pdf$", pdf))){
    stop("Error: input file not a pdf.")
  }

  if (!(grepl(".json$", json))){
    stop("Error: input file not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of token boundary boxes
  pages_lines <- output_as_list$pages$lines

  pagewise_line_sets <- purrr::map(pages_lines, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf),
                                    end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_line_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 0.8)

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 0.6,
           col = "blue")

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_lines.png")

    magick::image_write(img, format = "png", filename)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_lines)

  print(glue::glue("Generated {pages} annotated image(s)."))
}

#' Inspect token bounding boxes in Google Document AI json output
#'
#' This function extracts the token bounding box coordinates
#' from the json file returned by Google Document AI
#' and plots them on a copy of the source document
#' for human inspection.
#'
#' @param pdf filepath of the pdf sent for processing.
#' @param json filepath of the json output file.
#'
#' @details Not vectorized. Takes only pdf documents (if you processed .gif or .tiff files,
#' convert them to pdf first). Generates an annotated .png file for each page in the original pdf.
#' Assumes equal page length between the pdf and the json, so if the json output was split into shards,
#' split the pdf accordingly first.
#'
#' @export
#' @examples
#' \dontrun{
#' draw_tokens("pdf_page1.pdf", "pdf_output.json")
#' }

draw_tokens <- function(pdf,
                        json
                        ) {

  if (!(grepl(".pdf$", pdf))){
    stop("Error: input file not a pdf.")
  }

  if (!(grepl(".json$", json))){
    stop("Error: input file not .json.")
  }

  # split pdf into individual pages:
  tabulizer::split_pdf(pdf)

  # turn the json into a list
  output_as_list <- jsonlite::fromJSON(json)

  # extract a list with pagewise sets of token boundary boxes
  pages_tokens <- output_as_list$pages$tokens

  pagewise_token_sets <- purrr::map(pages_tokens, ~.x[["layout"]][["boundingPoly"]][["normalizedVertices"]])

  # create a vector with the individual pdf pages
  pdf_no_suffix <- stringr::str_sub(basename(pdf), end = -5)

  individual_pdfs <- list.files(tempdir(), pattern = glue::glue("{pdf_no_suffix}\\d+.pdf"), full.names = TRUE)

  # set counter for pdf vector
  counter <- 1

  # loop over the pagewise sets
  for (i in pagewise_token_sets){

    # read pdf into magick
    pdf_magick <- magick::image_read_pdf(individual_pdfs[counter])

    # get image dimensions
    info <- magick::image_info(pdf_magick)

    # prepare for plotting on image
    img <- magick::image_draw(pdf_magick)

    # set counter for box number
    counter2 <- 1

    #loop over boxes on the page
    for(box in i){

      # transform from relative to absolute coordinates
      box$x1 <- box$x * info$width

      box$y1 <- box$y * info$height

      # draw polygon
      graphics::polygon(x = box$x1,
                        y = box$y1,
                        border = "red",
                        lwd = 0.8)

      graphics::text(x = box$x1[1],
           y = box$y1[1],
           label = counter2,
           cex = 0.6,
           col = "blue")

      counter2 <- counter2 + 1
    }

    # write annotated image to file
    prefix <- stringr::str_sub(basename(individual_pdfs[counter]),
                               end=-5
                               )

    filename <- glue::glue("{prefix}_tokens.png")

    magick::image_write(img, format = "png", filename)

    grDevices::dev.off()

    counter <- counter + 1
  }

  pages <- length(pages_tokens)

  print(glue::glue("Generated {pages} annotated image(s)."))
}
