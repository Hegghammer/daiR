tables <- tables_from_dai_file(sample)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
})
test_that("tables_from_dai_response() warns of input errors", {
expect_error(tables_from_dai_response(NULL), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(12345), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(mtcars), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(as.matrix(mtcars)), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response("string"), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(c("string", "vector")), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(list("a", "list")), "Object is not a valid HTTP response.")
})
test_that("tables_from_dai_response() warns of response not containing tables", {
skip_if_no_token()
skip_if_offline()
wrong <- dai_user()
expect_error(tables_from_dai_response(wrong), "Object not a positive dai_sync response.")
blank <- dai_sync(testthat::test_path("examples", "blank.tiff"))
expect_error(tables_from_dai_response(blank), "DAI found no text. Was the page blank?")
no_tables <- dai_sync(testthat::test_path("examples", "sample.pdf"))
expect_error(tables_from_dai_response(no_tables), "DAI found no tables in the document.")
})
test_that("tables_from_dai_response() warns of response not containing tables", {
skip_if_no_token()
skip_if_offline()
wrong <- dai_user()
expect_error(tables_from_dai_response(wrong), "Object not a positive dai_sync response.")
blank <- dai_sync_tab(testthat::test_path("examples", "blank.tiff"))
expect_error(tables_from_dai_response(blank), "DAI found no text. Was the page blank?")
no_tables <- dai_sync_tab(testthat::test_path("examples", "sample.pdf"))
expect_error(tables_from_dai_response(no_tables), "DAI found no tables in the document.")
})
test_that("tables_from_dai_response() returns dataframes from dai response containing tables", {
skip_if_no_token()
skip_if_offline()
file <- testthat::test_path("examples", "table.pdf")
response <- dai_sync_tab(file)
tables <- tables_from_dai_response(response)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
})
test_that("tables_from_dai_file() warns of input errors", {
expect_error(tables_from_dai_file(NULL), "Invalid file input.")
expect_error(tables_from_dai_file(12345), "Invalid file input.")
expect_error(tables_from_dai_file(mtcars), "Invalid file input.")
expect_error(tables_from_dai_file(as.matrix(mtcars)), "Invalid file input.")
expect_error(tables_from_dai_file(c("string", "vector")), "Invalid file input.")
expect_error(tables_from_dai_file(list("a", "list")), "Invalid file input.")
expect_error(tables_from_dai_file("wrong.txt"), "Input file not .json. Is the file in your working directory?")
expect_error(tables_from_dai_file("fake.json"), "Input file not .json. Is the file in your working directory?")
})
test_that("tables_from_dai_file() warns of file not containing tables", {
random <- list("a" = 1, "b" = 2)
json <- jsonlite::toJSON(random)
madeup <- tempfile(fileext = ".json")
write(json, madeup)
expect_error(tables_from_dai_file(madeup), "JSON not in right format. Is it from DAI?")
blank <- testthat::test_path("examples", "output_blank.json")
expect_error(tables_from_dai_file(blank), "DAI found no text. Was the document blank?")
unlink(madeup, force = TRUE)
no_tables <- testthat::test_path("examples", "output.json")
expect_error(tables_from_dai_file(no_tables), "DAI found no tables in the document.")
})
test_that("tables_from_dai_file() reads real dai output file with tables", {
sample <- testthat::test_path("examples", "table_output.json")
tables <- tables_from_dai_file(sample)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
})
test_that("draw_blocks() warns of input errors", {
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
expect_error(draw_blocks(pdf = realpdf), 'argument "json" is missing, with no default')
expect_error(draw_blocks(json = realjson), 'argument "pdf" is missing, with no default')
expect_error(draw_blocks(12345, realjson), "Invalid pdf input.")
expect_error(draw_blocks(realpdf, 12345), "Invalid json input.")
expect_error(draw_blocks(mtcars, realjson), "Invalid pdf input.")
expect_error(draw_blocks(realpdf, mtcars), "Invalid json input.")
expect_error(draw_blocks(as.matrix(mtcars), realjson), "Invalid pdf input.")
expect_error(draw_blocks(realpdf, as.matrix(mtcars)), "Invalid json input.")
expect_error(draw_blocks(c("string.pdf", "vector.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_blocks(realpdf, c("string.json", "vector.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_blocks(list("a.pdf", "list.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_blocks(realpdf, list("a.json", "list.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_blocks(realpdf, "fake.json"), "Input 'json' not .json.")
expect_error(draw_blocks("fake.pdf", realjson), "Input 'pdf' not a pdf.")
})
test_that("draw_blocks() produces a correctly named png file", {
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
pages <- pdftools::pdf_info(realpdf)$pages
expected_message <- glue::glue("Generated {pages} annotated image*")
message <- capture.output(draw_blocks(realpdf, realjson), type = "message")
expect_match(message, expected_message)
expected_filepaths <- character()
for (i in pages) {
fname <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}{i}_blocks.png")
fpath <- file.path(tempdir(), fname)
expected_filepaths <- c(expected_filepaths, fpath)
}
for (j in 1:length(expected_filepaths)) {
expect_true(file.exists(expected_filepaths[j]))
}
unlink(expected_filepaths, force = TRUE)
})
test_that("draw_blocks() draws actual boxes on the png", {
skip_on_ci()
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
draw_blocks(realpdf, realjson)
filename <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}1_blocks.png")
filepath <- file.path(tempdir(), filename)
expect_snapshot_file(filepath, basename(filepath))
unlink(filepath, force = TRUE)
})
test_that("draw_paragraphs() warns of input errors", {
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
expect_error(draw_paragraphs(pdf = realpdf), 'argument "json" is missing, with no default')
expect_error(draw_paragraphs(json = realjson), 'argument "pdf" is missing, with no default')
expect_error(draw_paragraphs(12345, realjson), "Invalid pdf input.")
expect_error(draw_paragraphs(realpdf, 12345), "Invalid json input.")
expect_error(draw_paragraphs(mtcars, realjson), "Invalid pdf input.")
expect_error(draw_paragraphs(realpdf, mtcars), "Invalid json input.")
expect_error(draw_paragraphs(as.matrix(mtcars), realjson), "Invalid pdf input.")
expect_error(draw_paragraphs(realpdf, as.matrix(mtcars)), "Invalid json input.")
expect_error(draw_paragraphs(c("string.pdf", "vector.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_paragraphs(realpdf, c("string.json", "vector.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_paragraphs(list("a.pdf", "list.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_paragraphs(realpdf, list("a.json", "list.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_paragraphs(realpdf, "fake.json"), "Input 'json' not .json.")
expect_error(draw_paragraphs("fake.pdf", realjson), "Input 'pdf' not a pdf.")
})
test_that("draw_paragraphs() produces a correctly named new png file", {
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
pages <- pdftools::pdf_info(realpdf)$pages
expected_message <- glue::glue("Generated {pages} annotated image*")
message <- capture.output(draw_paragraphs(realpdf, realjson), type = "message")
expect_match(message, expected_message)
expected_filepaths <- character()
for (i in pages) {
fname <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}{i}_paragraphs.png")
fpath <- file.path(tempdir(), fname)
expected_filepaths <- c(expected_filepaths, fpath)
}
for (j in 1:length(expected_filepaths)) {
expect_true(file.exists(expected_filepaths[j]))
}
unlink(expected_filepaths, force = TRUE)
})
test_that("draw_paragraphs() draws actual boxes on the png", {
skip_on_ci()
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
draw_paragraphs(realpdf, realjson)
filename <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}1_paragraphs.png")
filepath <- file.path(tempdir(), filename)
expect_snapshot_file(filepath, basename(filepath))
unlink(filepath, force = TRUE)
})
test_that("draw_lines() warns of input errors", {
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
expect_error(draw_lines(pdf = realpdf), 'argument "json" is missing, with no default')
expect_error(draw_lines(json = realjson), 'argument "pdf" is missing, with no default')
expect_error(draw_lines(12345, realjson), "Invalid pdf input.")
expect_error(draw_lines(realpdf, 12345), "Invalid json input.")
expect_error(draw_lines(mtcars, realjson), "Invalid pdf input.")
expect_error(draw_lines(realpdf, mtcars), "Invalid json input.")
expect_error(draw_lines(as.matrix(mtcars), realjson), "Invalid pdf input.")
expect_error(draw_lines(realpdf, as.matrix(mtcars)), "Invalid json input.")
expect_error(draw_lines(c("string.pdf", "vector.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_lines(realpdf, c("string.json", "vector.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_lines(list("a.pdf", "list.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_lines(realpdf, list("a.json", "list.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_lines(realpdf, "fake.json"), "Input 'json' not .json.")
expect_error(draw_lines("fake.pdf", realjson), "Input 'pdf' not a pdf.")
})
test_that("draw_lines() produces a correctly named new png file", {
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
pages <- pdftools::pdf_info(realpdf)$pages
expected_message <- glue::glue("Generated {pages} annotated image*")
message <- capture.output(draw_lines(realpdf, realjson), type = "message")
expect_match(message, expected_message)
expected_filepaths <- character()
for (i in pages) {
fname <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}{i}_lines.png")
fpath <- file.path(tempdir(), fname)
expected_filepaths <- c(expected_filepaths, fpath)
}
for (j in 1:length(expected_filepaths)) {
expect_true(file.exists(expected_filepaths[j]))
}
unlink(expected_filepaths, force = TRUE)
})
test_that("draw_lines() draws actual boxes on the png", {
skip_on_ci()
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
draw_lines(realpdf, realjson)
filename <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}1_lines.png")
filepath <- file.path(tempdir(), filename)
expect_snapshot_file(filepath, basename(filepath))
unlink(filepath, force = TRUE)
})
test_that("draw_tokens() warns of input errors", {
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
expect_error(draw_tokens(pdf = realpdf), 'argument "json" is missing, with no default')
expect_error(draw_tokens(json = realjson), 'argument "pdf" is missing, with no default')
expect_error(draw_tokens(12345, realjson), "Invalid pdf input.")
expect_error(draw_tokens(realpdf, 12345), "Invalid json input.")
expect_error(draw_tokens(mtcars, realjson), "Invalid pdf input.")
expect_error(draw_tokens(realpdf, mtcars), "Invalid json input.")
expect_error(draw_tokens(as.matrix(mtcars), realjson), "Invalid pdf input.")
expect_error(draw_tokens(realpdf, as.matrix(mtcars)), "Invalid json input.")
expect_error(draw_tokens(c("string.pdf", "vector.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_tokens(realpdf, c("string.json", "vector.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_tokens(list("a.pdf", "list.pdf"), realjson), "Invalid pdf input. This function is not vectorised.")
expect_error(draw_tokens(realpdf, list("a.json", "list.json")), "Invalid json input. This function is not vectorised.")
expect_error(draw_tokens(realpdf, "fake.json"), "Input 'json' not .json.")
expect_error(draw_tokens("fake.pdf", realjson), "Input 'pdf' not a pdf.")
})
test_that("draw_tokens() produces a correctly named new png file", {
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
pages <- pdftools::pdf_info(realpdf)$pages
expected_message <- glue::glue("Generated {pages} annotated image*")
message <- capture.output(draw_tokens(realpdf, realjson), type = "message")
expect_match(message, expected_message)
expected_filepaths <- character()
for (i in pages) {
fname <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}{i}_tokens.png")
fpath <- file.path(tempdir(), fname)
expected_filepaths <- c(expected_filepaths, fpath)
}
for (j in 1:length(expected_filepaths)) {
expect_true(file.exists(expected_filepaths[j]))
}
unlink(expected_filepaths, force = TRUE)
})
test_that("draw_tokens() draws actual boxes on the png", {
skip_on_ci()
skip_if_not_installed("grDevices")
skip_if_not_installed("magick")
realpdf <- testthat::test_path("examples", "sample.pdf")
realjson <- testthat::test_path("examples", "output.json")
draw_tokens(realpdf, realjson)
filename <- glue::glue("{stringr::str_sub(basename(realpdf), end=-5)}1_tokens.png")
filepath <- file.path(tempdir(), filename)
expect_snapshot_file(filepath, basename(filepath))
unlink(filepath, force = TRUE)
})
library(devtools)
load_all()
setwd("D:/Dropbox/Jobb/Coding/RProjects/my_packages")
q <- dai_sync("tamimi2.jpg")
t2 <- text_from_dai_response(q)
cat(t2)
write(t2, "tamimi2.txt")
write.csv(t2, "tamimi2.txt", row.names = FALSE)
test_that("tables_from_dai_response() warns of input errors", {
expect_error(tables_from_dai_response(NULL), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(12345), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(mtcars), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(as.matrix(mtcars)), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response("string"), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(c("string", "vector")), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(list("a", "list")), "Object is not a valid HTTP response.")
})
test_that("tables_from_dai_response() warns of response not containing tables", {
skip_if_no_token()
skip_if_offline()
wrong <- dai_user()
expect_error(tables_from_dai_response(wrong), "Object not a positive dai_sync response.")
blank <- dai_sync_tab(testthat::test_path("examples", "blank.tiff"))
expect_error(tables_from_dai_response(blank), "DAI found no text. Was the page blank?")
no_tables <- dai_sync_tab(testthat::test_path("examples", "sample.pdf"))
expect_error(tables_from_dai_response(no_tables), "DAI found no tables in the document.")
})
# Authenticate during testing
#
# based on:
# - https://gargle.r-lib.org/articles/articles/managing-tokens-securely.html
# - https://github.com/tidyverse/googledrive/blob/master/tests/testthat/helper.R
test_auth <- function() {
has_internet <- !is.null(curl::nslookup(host = "r-project.org", error = FALSE))
if (has_internet && gargle:::secret_can_decrypt("daiR")) {
json <- gargle:::secret_read("daiR", "dair_testing.json")
dai_auth(path = rawToChar(json))
googleCloudStorageR::gcs_auth(json_file = rawToChar(json))
}
}
test_auth()
# Tell tester to skip test if no token
#
skip_if_no_token <- function() {
testthat::skip_if_not(dai_has_token(), "No DAI token")
}
# Get a (nearly) random pdf
#
# Takes a random, small-sized pdf from among the 76,000 Tobacco Truth Documents
# on archive.org, downloads it to tempdir, and returns the filepath.
get_random_pdf <- function() {
results <- internetarchive::ia_keyword_search("industrydocuments", num_results = 1000)
random <- sample(results, 1)
item <- internetarchive::ia_get_items(random)
page_ct <- item[[1]][["metadata"]][["pages"]]
pdf <- grep(".pdf$", names(item[[1]][["files"]]), value = TRUE)
size <- item[[1]][["files"]][[pdf]][["size"]]
while (size > 500000 && page_ct > 6) {
results <- internetarchive::ia_keyword_search("industrydocuments", num_results = 1000)
random <- sample(results, 1)
item <- internetarchive::ia_get_items(random)
page_ct <- item[[1]][["metadata"]][["pages"]]
pdf <- grep(".pdf$", names(item[[1]][["files"]]), value = TRUE)
size <- item[[1]][["files"]][[pdf]][["size"]]
}
server <- item[[1]][["server"]]
dir <-  item[[1]][["dir"]]
link <- glue::glue("http://{server}{dir}{pdf}")
dest <- file.path(tempdir(), basename(pdf))
download.file(link, dest, mode = "wb")
return(dest)
}
test_that("tables_from_dai_response() warns of input errors", {
expect_error(tables_from_dai_response(NULL), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(12345), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(mtcars), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(as.matrix(mtcars)), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response("string"), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(c("string", "vector")), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(list("a", "list")), "Object is not a valid HTTP response.")
})
test_that("tables_from_dai_response() warns of response not containing tables", {
skip_if_no_token()
skip_if_offline()
wrong <- dai_user()
expect_error(tables_from_dai_response(wrong), "Object not a positive dai_sync response.")
blank <- dai_sync_tab(testthat::test_path("examples", "blank.tiff"))
expect_error(tables_from_dai_response(blank), "DAI found no text. Was the page blank?")
no_tables <- dai_sync_tab(testthat::test_path("examples", "sample.pdf"))
expect_error(tables_from_dai_response(no_tables), "DAI found no tables in the document.")
})
setwd("D:/Dropbox/Jobb/Coding/RProjects/my_packages/daiR_released")
test_that("tables_from_dai_response() warns of response not containing tables", {
skip_if_no_token()
skip_if_offline()
wrong <- dai_user()
expect_error(tables_from_dai_response(wrong), "Object not a positive dai_sync response.")
blank <- dai_sync_tab(testthat::test_path("examples", "blank.tiff"))
expect_error(tables_from_dai_response(blank), "DAI found no text. Was the page blank?")
no_tables <- dai_sync_tab(testthat::test_path("examples", "sample.pdf"))
expect_error(tables_from_dai_response(no_tables), "DAI found no tables in the document.")
})
test_that("tables_from_dai_response() returns dataframes from dai response containing tables", {
skip_if_no_token()
skip_if_offline()
file <- testthat::test_path("examples", "table.pdf")
response <- dai_sync_tab(file)
tables <- tables_from_dai_response(response)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
})
skip_if_no_token()
skip_if_offline()
file <- testthat::test_path("examples", "table.pdf")
response <- dai_sync_tab(file)
tables <- tables_from_dai_response(response)
tables <- tables_from_dai_response(response)
tables <- tables_from_dai_response(response)
expect_true(is.list(tables))
library(devtools)
load_all()
# Authenticate during testing
#
# based on:
# - https://gargle.r-lib.org/articles/articles/managing-tokens-securely.html
# - https://github.com/tidyverse/googledrive/blob/master/tests/testthat/helper.R
test_auth <- function() {
has_internet <- !is.null(curl::nslookup(host = "r-project.org", error = FALSE))
if (has_internet && gargle:::secret_can_decrypt("daiR")) {
json <- gargle:::secret_read("daiR", "dair_testing.json")
dai_auth(path = rawToChar(json))
googleCloudStorageR::gcs_auth(json_file = rawToChar(json))
}
}
test_auth()
# Tell tester to skip test if no token
#
skip_if_no_token <- function() {
testthat::skip_if_not(dai_has_token(), "No DAI token")
}
# Get a (nearly) random pdf
#
# Takes a random, small-sized pdf from among the 76,000 Tobacco Truth Documents
# on archive.org, downloads it to tempdir, and returns the filepath.
get_random_pdf <- function() {
results <- internetarchive::ia_keyword_search("industrydocuments", num_results = 1000)
random <- sample(results, 1)
item <- internetarchive::ia_get_items(random)
page_ct <- item[[1]][["metadata"]][["pages"]]
pdf <- grep(".pdf$", names(item[[1]][["files"]]), value = TRUE)
size <- item[[1]][["files"]][[pdf]][["size"]]
while (size > 500000 && page_ct > 6) {
results <- internetarchive::ia_keyword_search("industrydocuments", num_results = 1000)
random <- sample(results, 1)
item <- internetarchive::ia_get_items(random)
page_ct <- item[[1]][["metadata"]][["pages"]]
pdf <- grep(".pdf$", names(item[[1]][["files"]]), value = TRUE)
size <- item[[1]][["files"]][[pdf]][["size"]]
}
server <- item[[1]][["server"]]
dir <-  item[[1]][["dir"]]
link <- glue::glue("http://{server}{dir}{pdf}")
dest <- file.path(tempdir(), basename(pdf))
download.file(link, dest, mode = "wb")
return(dest)
}
test_that("tables_from_dai_response() warns of input errors", {
expect_error(tables_from_dai_response(NULL), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(12345), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(mtcars), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(as.matrix(mtcars)), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response("string"), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(c("string", "vector")), "Object is not a valid HTTP response.")
expect_error(tables_from_dai_response(list("a", "list")), "Object is not a valid HTTP response.")
})
test_that("tables_from_dai_response() warns of response not containing tables", {
skip_if_no_token()
skip_if_offline()
wrong <- dai_user()
expect_error(tables_from_dai_response(wrong), "Object not a positive dai_sync response.")
blank <- dai_sync_tab(testthat::test_path("examples", "blank.tiff"))
expect_error(tables_from_dai_response(blank), "DAI found no text. Was the page blank?")
no_tables <- dai_sync_tab(testthat::test_path("examples", "sample.pdf"))
expect_error(tables_from_dai_response(no_tables), "DAI found no tables in the document.")
})
test_that("tables_from_dai_response() returns dataframes from dai response containing tables", {
skip_if_no_token()
skip_if_offline()
file <- testthat::test_path("examples", "table.pdf")
response <- dai_sync_tab(file)
tables <- tables_from_dai_response(response)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
})
file <- testthat::test_path("examples", "table.pdf")
response <- dai_sync_tab(file)
tables <- tables_from_dai_response(response)
expect_true(is.list(tables))
load_all()
skip_if_no_token()
skip_if_offline()
file <- testthat::test_path("examples", "table.pdf")
response <- dai_sync_tab(file)
tables <- tables_from_dai_response(response)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
test_that("tables_from_dai_file() warns of input errors", {
expect_error(tables_from_dai_file(NULL), "Invalid file input.")
expect_error(tables_from_dai_file(12345), "Invalid file input.")
expect_error(tables_from_dai_file(mtcars), "Invalid file input.")
expect_error(tables_from_dai_file(as.matrix(mtcars)), "Invalid file input.")
expect_error(tables_from_dai_file(c("string", "vector")), "Invalid file input.")
expect_error(tables_from_dai_file(list("a", "list")), "Invalid file input.")
expect_error(tables_from_dai_file("wrong.txt"), "Input file not .json. Is the file in your working directory?")
expect_error(tables_from_dai_file("fake.json"), "Input file not .json. Is the file in your working directory?")
})
test_that("tables_from_dai_file() warns of file not containing tables", {
random <- list("a" = 1, "b" = 2)
json <- jsonlite::toJSON(random)
madeup <- tempfile(fileext = ".json")
write(json, madeup)
expect_error(tables_from_dai_file(madeup), "JSON not in right format. Is it from DAI?")
blank <- testthat::test_path("examples", "output_blank.json")
expect_error(tables_from_dai_file(blank), "DAI found no text. Was the document blank?")
unlink(madeup, force = TRUE)
no_tables <- testthat::test_path("examples", "output.json")
expect_error(tables_from_dai_file(no_tables), "DAI found no tables in the document.")
})
test_that("tables_from_dai_file() reads real dai output file with tables", {
sample <- testthat::test_path("examples", "table_output.json")
tables <- tables_from_dai_file(sample)
expect_true(is.list(tables))
expect_true(all(sapply(tables, is.data.frame)))
})
# package checks
devtools::load_all()
devtools::document()
devtools::test()
devtools::document()
document()
install.packages(c("broom", "callr", "cli", "cpp11", "dbplyr", "devtools", "diffobj", "e1071", "gargle", "gert", "gh", "googleAuthR", "magick", "pkgload", "processx", "ragg", "remotes", "reprex", "sf", "textshaping", "tiff", "tinytex", "units", "vctrs", "WDI"))
install.packages("devtools")
