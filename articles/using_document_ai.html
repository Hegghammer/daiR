<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Using Google Document AI with R • daiR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/united/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Using Google Document AI with R">
<meta property="og:description" content="daiR">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-NL6TR4PT51"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NL6TR4PT51');
</script>
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">daiR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="../articles/basics.html">Quickstart</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/setting_up_google_storage.html">Setting up a Google Storage bucket</a>
    </li>
    <li>
      <a href="../articles/using_document_ai.html">Using Google Document AI with R</a>
    </li>
    <li>
      <a href="../articles/extracting_tables.html">Extracting tables</a>
    </li>
    <li>
      <a href="../articles/reconstructing_text.html">Correcting text output from Google Document AI</a>
    </li>
    <li>
      <a href="../articles/complex_file_and_folder_management.html">Complex file and folder management</a>
    </li>
    <li>
      <a href="../articles/searchable_pdfs">Creating searchable PDFs</a>
    </li>
  </ul>
</li>
<li>
  <a href="../articles/faqs.html">FAQs</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="https://github.com/hegghammer/dair/" class="external-link">
    <span class="fab fa-github"></span>
     
    Github
  </a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/Hegghammer/daiR/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Using Google Document AI with R</h1>
                        <h4 data-toc-skip class="author">Thomas
Hegghammer</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/Hegghammer/daiR/blob/HEAD/vignettes/using_document_ai.Rmd" class="external-link"><code>vignettes/using_document_ai.Rmd</code></a></small>
      <div class="hidden name"><code>using_document_ai.Rmd</code></div>

    </div>

    
    
<p><strong>Last updated 14 April 2021</strong><br><strong>Command line users: See <a href="https://dair.info/articles/gcs_cli.html" class="external-link">here</a> for GCS setup
using gcloud CLI.</strong><br><br></p>
<div class="section level3">
<h3 id="about-document-ai">About Document AI<a class="anchor" aria-label="anchor" href="#about-document-ai"></a>
</h3>
<p><a href="https://cloud.google.com/document-ai" class="external-link">Google Document AI</a>
(DAI) is a server-based OCR engine that extracts text from pdf files.
Released in November 2020, it is much more powerful than static
libraries such as <a href="https://github.com/tesseract-ocr/tesseract" class="external-link"><code>tesseract</code></a>.
Short of corpus-specific, self-trained processors, DAI offers some of
the best OCR capabilities currently available to the general public. At
the time of writing, DAI is more expensive than Amazon’s <a href="https://aws.amazon.com/textract/" class="external-link">Textract</a>, but promises to
support many more languages.</p>
<p>DAI is accessed through an API, but this API currently has no
official R <a href="https://cloud.google.com/document-ai/docs/libraries" class="external-link">client
library</a>. This is where the <code>daiR</code> package comes in; it
provides a light wrapper for DAI’s <a href="https://cloud.google.com/document-ai/docs/reference/rest" class="external-link">REST
API</a>, making it possible to submit documents to DAI from within R. In
addition, <code>daiR</code> comes with pre- and postprocessing tools
intended to make the whole text extraction process easier.</p>
<p>Google Document AI is closely connected with <a href="https://cloud.google.com/storage" class="external-link">Google Storage</a>, as the
latter serves as a drop-off and pick-up point for files you want
processed in DAI. An R workflow for DAI processing consists of three
core steps:</p>
<ol style="list-style-type: decimal">
<li>Upload your files to a Google Storage bucket. This can be done
manually in the <a href="https://console.cloud.google.com/storage/" class="external-link">Google Cloud
Console</a> or programmatically with the package <a href="https://code.markedmondson.me/googleCloudStorageR/index.html" class="external-link"><code>googleCloudStorager</code></a>.</li>
<li>Using <code>daiR</code>, tell DAI to process the files in your
bucket. DAI will return its output to your Storage bucket in the form of
json files.</li>
<li>Download the json files from your Storage bucket to your hard drive.
Again you can use either the Cloud Console or
<code>googleCloudStorager</code>.</li>
</ol>
</div>
<div class="section level3">
<h3 id="setup">Setup<a class="anchor" aria-label="anchor" href="#setup"></a>
</h3>
<p>A <a href="https://dair.info/articles/setting_up_google_storage.html" class="external-link">previous
vignette</a> covered the setting up of a Google Cloud service account
and interacting with Google Storage. Here we pick up from where that
vignette left off, and assume that the following things are in
place:</p>
<ol style="list-style-type: decimal">
<li>A Google Cloud Services (GCS) <strong>project</strong> linked to
your billing account and with the Document AI API enabled.</li>
<li>A <strong>service account</strong> with the role “Owner”.</li>
<li>A <strong>json file</strong> with the service account key, the path
to which is stored in an environment variable called
<code>GCS_AUTH_FILE</code>.</li>
<li>The name of your default bucket stored in an environment variable
called <code>GCS_DEFAULT_BUCKET</code>.</li>
</ol>
<p>To use Document AI, we need to complete a few more steps.</p>
<div class="section level4">
<h4 id="step-1-activate-document-ai">Step 1: Activate Document AI<a class="anchor" aria-label="anchor" href="#step-1-activate-document-ai"></a>
</h4>
<p>First, we must activate the API. Go to the <a href="https://console.cloud.google.com/" class="external-link">Google Cloud Console</a> and
open the navigation menu on the left hand side. Click on “APIs and
services”. Then click on “Enable APIs and Services”, type “document ai”
in the search field, click on “cloud document ai API”, and then
“Enable”.</p>
</div>
<div class="section level4">
<h4 id="step-2-create-a-processor">Step 2: Create a processor<a class="anchor" aria-label="anchor" href="#step-2-create-a-processor"></a>
</h4>
<p>In order to process documents, you need to set up an OCR processor.
This is done in R using the function
<code><a href="../reference/create_processor.html">daiR::create_processor</a></code>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> We start by loading the <code>daiR</code>
package.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Hegghammer/daiR" class="external-link">daiR</a></span><span class="op">)</span></span></code></pre></div>
<p>You now need to think of a globally unique display name for the
processor, to be supplied with the <code><a href="../reference/create_processor.html">create_processor()</a></code>
function. Processor names are shared across the GCS ecosystem, so simple
ones like “processor” or “my-processor” are probably already taken.
Instead try something along the lines of “thomas-proc-2024”.</p>
<p>If successful, the <code><a href="../reference/create_processor.html">create_processor()</a></code> function will
return a processor id, a 16-character sequence of random numbers and
letters. Take good note of it.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## NOT RUN</span></span>
<span><span class="fu"><a href="../reference/create_processor.html">create_processor</a></span><span class="op">(</span><span class="st">"&lt;my-unique-processor-name&gt;"</span><span class="op">)</span></span></code></pre></div>
<p>It is possible to create more than one processor, but most users only
need one at any given time. To view your processors, run
<code><a href="../reference/get_processors.html">daiR::get_processors()</a></code>. Should you wish to delete one, use
<code><a href="../reference/delete_processor.html">daiR::delete_processor()</a></code>. There are several <a href="https://dair.info/articles/faqs.html#how-many-different-processors-are-there" class="external-link">different
types of processors</a> available, but most users will want the generic
one (called <code>OCR_PROCESSOR</code>), and this is what
<code><a href="../reference/create_processor.html">daiR::create_processor()</a></code> defaults to.</p>
</div>
<div class="section level4">
<h4 id="step-3-store-the-processor-id-as-an-environment-variable">Step 3: Store the processor id as an environment variable<a class="anchor" aria-label="anchor" href="#step-3-store-the-processor-id-as-an-environment-variable"></a>
</h4>
<p>Every Document AI processing request needs to contain a processor id,
so I strongly recommend storing the id you just generated in an
environment variable called <code>DAI_PROCESSOR_ID</code>. All of
<code>daiR</code>’s processing functions are set up to look for this
variable.</p>
<p>Open your <code>.Renviron</code> file by calling
<code><a href="https://usethis.r-lib.org/reference/edit.html" class="external-link">usethis::edit_r_environ()</a></code>. Add
<code>DAI_PROCESSOR_ID="&lt;your processor id&gt;"</code> on a separate
line. Save <code>.Renviron</code> and restart RStudio.</p>
<p>That’s it. If these things are in place, you can start
processing.</p>
</div>
</div>
<div class="section level3">
<h3 id="synchronous-processing">Synchronous processing<a class="anchor" aria-label="anchor" href="#synchronous-processing"></a>
</h3>
<p>The quickest and easiest way to OCR with DAI is through synchronous
processing. You simply pass an image file or a pdf (of up to 5 pages) to
the processor and get the result into your R environment within
seconds.</p>
<p>We can try with a sample pdf from the CIA’s Freedom of Information
Act Electronic Reading Room:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Hegghammer/daiR" class="external-link">daiR</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/getwd.html" class="external-link">setwd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempdir</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/download.file.html" class="external-link">download.file</a></span><span class="op">(</span><span class="st">"https://www.cia.gov/readingroom/docs/AGH%2C%20LASLO_0011.pdf"</span>, </span>
<span>              destfile <span class="op">=</span> <span class="st">"CIA.pdf"</span>, </span>
<span>              mode <span class="op">=</span> <span class="st">"wb"</span><span class="op">)</span></span></code></pre></div>
<p>We send it to Document AI with <code><a href="../reference/dai_sync.html">dai_sync()</a></code> and store the
HTTP response in an object, for example <code>response</code>.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">response1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dai_sync.html">dai_sync</a></span><span class="op">(</span><span class="st">"CIA.pdf"</span><span class="op">)</span></span></code></pre></div>
<p>Then we extract the text with
<code><a href="../reference/text_from_dai_response.html">text_from_dai_response()</a></code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">text</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/text_from_dai_response.html">text_from_dai_response</a></span><span class="op">(</span><span class="va">response1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">text</span><span class="op">)</span></span></code></pre></div>
<p>Synchronous processing is very convenient, but has two limitations.
One is that OCR accuracy may be slightly reduced compared with
asynchronous processing, because <code><a href="../reference/dai_sync.html">dai_sync()</a></code> converts the
source file to a lightweight, grayscale image before passing it to DAI.
The other is scaling; If you have a large pdf or many files, it is
usually easier to process them asynchronously.</p>
<p>However, it is possible to iterate <code><a href="../reference/dai_sync.html">dai_sync()</a></code> over a
vector of filepaths, and this can make sense for medium sized batches. I
recommend adding a small pause so as not to run into rate limit issues.
A sample script might look like this:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## NOT RUN</span></span>
<span><span class="co"># Create vector of document filepaths</span></span>
<span><span class="va">myfiles</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"file1.png"</span>, <span class="st">"file2.png"</span>, <span class="st">"file3.png"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create custom function</span></span>
<span><span class="va">ocr_and_save</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">filepath</span>, <span class="va">destdir</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">resp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dai_sync.html">dai_sync</a></span><span class="op">(</span><span class="va">filepath</span><span class="op">)</span></span>
<span>  <span class="va">stem</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">gsub</a></span><span class="op">(</span><span class="st">"\\.png"</span>, <span class="st">""</span>, <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="va">filepath</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="../reference/text_from_dai_response.html">text_from_dai_response</a></span><span class="op">(</span><span class="va">resp</span>,</span>
<span>                         save_to_file <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                         dest_dir <span class="op">=</span> <span class="va">destdir</span>,</span>
<span>                         filename <span class="op">=</span> <span class="va">stem</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Create output directory if it does not exist</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/files2.html" class="external-link">dir.create</a></span><span class="op">(</span><span class="st">"output"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Loop over vector. Add print statement so you know where you are in case it stops</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">myfiles</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu">glue</span><span class="fu">::</span><span class="fu"><a href="https://glue.tidyverse.org/reference/glue.html" class="external-link">glue</a></span><span class="op">(</span><span class="st">"Processing file {i} of {length(myfiles)} .."</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu">ocr_and_save</span><span class="op">(</span><span class="va">myfiles</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="st">"output"</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="asynchronous-processing">Asynchronous processing<a class="anchor" aria-label="anchor" href="#asynchronous-processing"></a>
</h3>
<p>In asynchronous (offline) processing, you don’t send DAI the actual
document, but rather its location on Google Storage so that DAI can
process it “in its own time”. While slower than synchronous OCR, it
allows for batch processing and makes the process less vulnerable to
interruptions (like laptop battery death or inadvertent closing of your
console). The <code>daiR</code> function <code><a href="../reference/dai_async.html">dai_async()</a></code> is
vectorized, so you can send multiple files with a single call. For this
vignette, however, we’ll just use a single document; the same as in the
previous example.</p>
<p>The first step is to upload the source file(s) to a Google Storage
bucket where DAI can find it.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://code.markedmondson.me/googleCloudStorageR/" class="external-link">googleCloudStorageR</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_upload.html" class="external-link">gcs_upload</a></span><span class="op">(</span><span class="st">"CIA.pdf"</span><span class="op">)</span></span></code></pre></div>
<p>Let’s check that our file made it safely:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_list_objects.html" class="external-link">gcs_list_objects</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>We’re now ready to send it off to Document AI with
<code>daiR</code>’s workhorse function, <code><a href="../reference/dai_async.html">dai_async()</a></code>, as
follows:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">response2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dai_async.html">dai_async</a></span><span class="op">(</span><span class="st">"CIA.pdf"</span><span class="op">)</span></span></code></pre></div>
<p>A few words about this function. Its core parameter,
<code>files</code>, tells DAI what to process. You can submit either
.pdf, .gif, or .tiff files, and your <code>files</code> vector can
contain a mixture of these three file formats.</p>
<p>You can also specify a <code>dest_folder</code>: the name of the
bucket folder where you want the output. It defaults to the root of the
bucket, but you can specify another subfolder. If the folder does not
exist already, it will be created.</p>
<p>The function also takes a location parameter (<code>loc</code>),
which defaults to “eu” but can be set to “us”. It has nothing to do with
where you are based, but with which of Google’s servers will process
your files. The parameter <code>skip_rev</code> can be ignored by most;
it is for passing selected documents to human review in business
workflows. The remaining parameters default to things that are defined
by your environment variables (provided you followed the recommendations
above).</p>
<p>Back to our processing. If your call returned “status: 200”, it was
accepted by the API. This does not necessarily mean that the processing
was successful, because the API has no way of knowing right away if the
filepaths you provided exist in your bucket. If there were errors in
your filepaths, your HTTP request would get a 200, but your files would
not actually process. They would turn up as empty files in the folder
you provided. So if you see json files of around 70 bytes each in the
destination folder, you know there was something wrong with your
filenames.</p>
<p>You can check the status of a job with <code><a href="../reference/dai_status.html">dai_status()</a></code>.
Just pass the response object from your <code><a href="../reference/dai_async.html">dai_async()</a></code> into
the parentheses, and it will tell you whether the job is finished. It
won’t tell you how much time remains, but in my experience, processing
takes about 5-20 seconds per page.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/dai_status.html">dai_status</a></span><span class="op">(</span><span class="va">response2</span><span class="op">)</span></span></code></pre></div>
<p>When <code><a href="../reference/dai_status.html">dai_status()</a></code> says “SUCCEEDED”, the json output
files are waiting for you in the bucket.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_list_objects.html" class="external-link">gcs_list_objects</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>Output file names look cryptic, but there’s a logic to them, namely:
<code>"&lt;job_number&gt;/&lt;document_number&gt;/&lt;filename&gt;-&lt;shard_number&gt;.json"</code>
Our file will thus take the form
<code>"&lt;job_number&gt;/0/CIA-0.json"</code>, with
<code>&lt;job_number&gt;</code> changing from one processing call to the
next. Let us store the name in a vector for simplicity:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## NOT RUN</span></span>
<span><span class="va">our_file</span> <span class="op">&lt;-</span> <span class="st">"&lt;job_number&gt;/0/CIA-0.json"</span></span></code></pre></div>
<p>Now let’s download it and save it under a simpler name:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_get_object.html" class="external-link">gcs_get_object</a></span><span class="op">(</span><span class="va">our_file</span>, saveToDisk <span class="op">=</span> <span class="st">"CIA.json"</span>, overwrite <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Finally we extract the text using
<code>text_from_dai_file</code>:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">text</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/text_from_dai_file.html">text_from_dai_file</a></span><span class="op">(</span><span class="st">"CIA.json"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">text</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="large-batches">Large batches<a class="anchor" aria-label="anchor" href="#large-batches"></a>
</h2>
<p>Although <code><a href="../reference/dai_async.html">dai_async()</a></code> takes batches of files, it is
constrained by Google’s <a href="https://cloud.google.com/document-ai/quotas" class="external-link">rate limits</a>.
Currently, a <code><a href="../reference/dai_async.html">dai_async()</a></code> call can contain maximum 50 files
(a multi-page pdf counts as one file), and you can not have more than 5
batch requests and 10 000 pages undergoing processing at any one
time.</p>
<p>Therefore, if you’re looking to process a large batch, you need to
spread the <code><a href="../reference/dai_async.html">dai_async()</a></code> calls out over time. The simplest
solution is to make a function that sends files off individually with a
small wait in between. Say we have a vector called
<code>big_batch</code> containing thousands of filenames. First we would
make a function like this:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">process_slowly</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">file</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/dai_async.html">dai_async</a></span><span class="op">(</span><span class="va">file</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">15</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Then we would iterate it over our file vector:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## NOT RUN</span></span>
<span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html" class="external-link">map</a></span><span class="op">(</span><span class="va">big_batch</span>, <span class="va">process_slowly</span><span class="op">)</span></span></code></pre></div>
<p>This will hold up your console for a while, so it may be worth doing
in the background as an RStudio <a href="https://posit.co/blog/rstudio-1-2-jobs/" class="external-link">job</a>.</p>
<p>Finding the optimal wait time for <code><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep()</a></code> may
require some trial and error. As a rule of thumb, it should approximate
the time it takes for DAI to process <em>one</em> of your files. This,
in turn, depends on the size of the files, for a 100-page pdf will take
a lot longer to process than a single-page one. In my experience, a
10-second interval is ample time for a batch of single-page PDFs.
Multi-page pdfs require proportionally more time. If your files vary in
size, calibrate the wait time to the largest file, or you may get 429s
(HTTP code for “rate limit exceeded”) half way through the
iteration.</p>
<p>Although this procedure is relatively slow, it need not add much to
the overall processing time. DAI starts processing the first files it
receives right away, so when your loop ends, DAI will be mostly done
with the OCR as well.</p>
</div>
<div class="section level2">
<h2 id="merging-shards">Merging shards<a class="anchor" aria-label="anchor" href="#merging-shards"></a>
</h2>
<p>If you have long PDFs, DAI will break the output into shards, meaning
that, for a single PDF file, you may get back multiple JSON files named
<code>*-1.json</code>, <code>*-2.json</code>m, etc.</p>
<p>To weave the text back together again, you can use the
<code><a href="../reference/merge_shards.html">merge_shards()</a></code> function. It works on text files, not JSON
files, so you need to extract the text from the JSONs first. You also
need to keep the name stem – turning <code>document-1.json</code> into
<code>document-1.txt</code> and so forth – so that
<code><a href="../reference/merge_shards.html">merge_shards()</a></code> knows which pieces belong together. This can
be done by setting the <code>save_to_file</code> parameter to
<code>TRUE</code> in <code><a href="../reference/text_from_dai_file.html">text_from_dai_file()</a></code>.</p>
<p>Here is a sample workflow:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="do">## NOT RUN</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>shards <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"longdoc-1.json"</span>, <span class="st">"longdoc-2.json"</span>, <span class="st">"longdoc-3.json"</span>)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="fu">dir.create</span>(<span class="fu">c</span>(<span class="st">"txt_split"</span>, <span class="st">"txt_joined"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="fu">map</span>(shards, <span class="sc">~</span> <span class="fu">text_from_dai_file</span>(.x, <span class="at">save_to_file =</span> <span class="cn">TRUE</span>, <span class="at">dest_dir =</span> <span class="st">"txt_split"</span>)</span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="fu">merge_shards</span>(<span class="at">source_dir =</span> <span class="st">"txt_split"</span>, <span class="at">dest_dir =</span> <span class="st">"txt_joined"</span>)</span></code></pre></div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>It is also possible to create processors manually in the
Google Cloud Console.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Note that if you do not have a
<code>GCS_DEFAULT_BUCKET</code> variable in your .Renviron file, you
will need to either set a default bucket for the current session with
<code>gcs_global_bucket("&lt;a bucket name&gt;")</code> or supply a
<code>bucket = "&lt;a bucket name&gt;"</code> parameter explicitly
inside <code><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_upload.html" class="external-link">gcs_upload()</a></code>.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Thomas Hegghammer.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
