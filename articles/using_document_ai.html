<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Using Google Document AI with R • daiR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/united/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Using Google Document AI with R">
<meta property="og:description" content="daiR">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-NL6TR4PT51"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NL6TR4PT51');
</script>
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">daiR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.9.7</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="../articles/basics.html">Quickstart</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/setting_up_google_storage.html">Setting up a Google Storage bucket</a>
    </li>
    <li>
      <a href="../articles/using_document_ai.html">Using Google Document AI with R</a>
    </li>
    <li>
      <a href="../articles/extracting_tables.html">Extracting tables</a>
    </li>
    <li>
      <a href="../articles/reconstructing_text.html">Correcting text output from Google Document AI</a>
    </li>
    <li>
      <a href="../articles/complex_file_and_folder_management.html">Complex file and folder management</a>
    </li>
  </ul>
</li>
<li>
  <a href="../articles/faqs.html">FAQs</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="https://github.com/hegghammer/dair/" class="external-link">
    <span class="fab fa-github"></span>
     
    Github
  </a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/Hegghammer/daiR/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Using Google Document AI with R</h1>
                        <h4 data-toc-skip class="author">Thomas
Hegghammer</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/Hegghammer/daiR/blob/HEAD/vignettes/using_document_ai.Rmd" class="external-link"><code>vignettes/using_document_ai.Rmd</code></a></small>
      <div class="hidden name"><code>using_document_ai.Rmd</code></div>

    </div>

    
    
<p><strong>Last updated 14 April 2021</strong><br><br><br></p>
<div class="section level3">
<h3 id="about-document-ai">About Document AI<a class="anchor" aria-label="anchor" href="#about-document-ai"></a>
</h3>
<p><a href="https://cloud.google.com/document-ai" class="external-link">Google Document AI</a>
(DAI) is a server-based OCR engine that extracts text from pdf files.
Released in November 2020, it is much more powerful than static
libraries such as <a href="https://github.com/tesseract-ocr/tesseract" class="external-link"><code>tesseract</code></a>.
Short of corpus-specific, self-trained processors, DAI offers some of
the best OCR capabilities currently available to the general public. At
the time of writing, DAI is more expensive than Amazon’s <a href="https://aws.amazon.com/textract/" class="external-link">Textract</a>, but promises to
support many more languages.</p>
<p>DAI is accessed through an API, but this API currently has no
official R <a href="https://cloud.google.com/document-ai/docs/libraries" class="external-link">client
library</a>. This is where the <code>daiR</code> package comes in; it
provides a light wrapper for DAI’s <a href="https://cloud.google.com/document-ai/docs/reference/rest" class="external-link">REST
API</a>, making it possible to submit documents to DAI from within R. In
addition, <code>daiR</code> comes with pre- and postprocessing tools
intended to make the whole text extraction process easier.</p>
<p>Google Document AI is closely connected with <a href="https://cloud.google.com/storage" class="external-link">Google Storage</a>, as the
latter serves as a drop-off and pick-up point for files you want
processed in DAI. An R workflow for DAI processing consists of three
core steps:</p>
<ol style="list-style-type: decimal">
<li>Upload your files to a Google Storage bucket. This can be done
manually in the <a href="https://console.cloud.google.com/storage/" class="external-link">Google Cloud
Console</a> or programmatically with the package <a href="https://code.markedmondson.me/googleCloudStorageR/index.html" class="external-link"><code>googleCloudStorager</code></a>.</li>
<li>Using <code>daiR</code>, tell DAI to process the files in your
bucket. DAI will return its output to your Storage bucket in the form of
json files.</li>
<li>Download the json files from your Storage bucket to your hard drive.
Again you can use either the Cloud Console or
<code>googleCloudStorager</code>.</li>
</ol>
</div>
<div class="section level3">
<h3 id="setup">Setup<a class="anchor" aria-label="anchor" href="#setup"></a>
</h3>
<p>A <a href="https://dair.info/articles/setting_up_google_storage.html" class="external-link">previous
vignette</a> covered the setting up of a Google Cloud service account
and interacting with Google Storage. Here we pick up from where that
vignette left off, and assume that the following things are in
place:</p>
<ol style="list-style-type: decimal">
<li>A Google Cloud Services (GCS) <strong>project</strong> linked to
your billing account and with the Document AI API enabled.</li>
<li>A <strong>service account</strong> with the role “Owner”.</li>
<li>A <strong>json file</strong> with the service account key, the path
to which is stored in an environment variable called
<code>GCS_AUTH_FILE</code>.</li>
<li>The name of your default bucket stored in an environment variable
called <code>GCS_DEFAULT_BUCKET</code>.</li>
</ol>
<p>To use Document AI, we need to complete a few more steps.</p>
<div class="section level4">
<h4 id="step-1-activate-document-ai">Step 1: Activate Document AI<a class="anchor" aria-label="anchor" href="#step-1-activate-document-ai"></a>
</h4>
<p>First, we must activate the API. Go to the <a href="https://console.cloud.google.com/" class="external-link">Google Cloud Console</a> and
open the navigation menu on the left hand side. Click on “APIs and
services”. Then click on “Enable APIs and Services”, type “document ai”
in the search field, click on “cloud document ai API”, and then
“Enable”.</p>
</div>
<div class="section level4">
<h4 id="step-2-create-a-processor">Step 2: Create a processor<a class="anchor" aria-label="anchor" href="#step-2-create-a-processor"></a>
</h4>
<p>Open the navigation menu on the left again. Scroll down, almost to
the bottom, till you see “Document AI” (under the group heading
“Artificial intelligence”). Click on “Document AI”.</p>
<p>Now click the blue button labelled “Create processor”. On the next
page, choose the “Document OCR” processor type. A pane should open on
your right where you can choose a name for the processor. Call it what
you like; the name is mainly for your own reference. Select a location
(where you want your files to be processed), then click create.</p>
<p>You should now see a page listing the processor’s Name, ID, Status
and other attributes. The main thing you want here is the
<strong>ID</strong>. Select it and copy it to the clipboard.</p>
</div>
<div class="section level4">
<h4 id="step-3-store-the-processor-id-as-an-environment-variable">Step 3: Store the processor id as an environment variable<a class="anchor" aria-label="anchor" href="#step-3-store-the-processor-id-as-an-environment-variable"></a>
</h4>
<p>Open your <code>.Renviron</code> file by calling
<code><a href="https://usethis.r-lib.org/reference/edit.html" class="external-link">usethis::edit_r_environ()</a></code>. Add
<code>DAI_PROCESSOR_ID="&lt;your processor id&gt;"</code> on a separate
line. Save <code>.Renviron</code> and restart RStudio.</p>
<p>That’s it. If these things are in place, you can start processing
right after loading the package.</p>
<p><strong>A note on access tokens</strong>: Unlike some other GCS
wrappers, daiR does not authenticate on startup and store access tokens
in the environment. Instead it generates tokens on a per-call basis. If
you prefer to generate one token per session, you can use
<code><a href="../reference/dai_token.html">dai_token()</a></code> to store your token in an object and pass that
object directly into the API call functions using the latter’s
<code>token =</code> parameter. This also means you can use auth
functions from pretty much any other GCS wrapper to generate your
token.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Hegghammer/daiR" class="external-link">daiR</a></span><span class="op">)</span></span></code></pre></div>
<p>Now let’s try this thing out.</p>
</div>
</div>
<div class="section level3">
<h3 id="synchronous-processing">Synchronous processing<a class="anchor" aria-label="anchor" href="#synchronous-processing"></a>
</h3>
<p>The quickest and easiest way to OCR with DAI is through synchronous
processing. You simply pass an image file or a pdf (of up to 5 pages) to
the processor and get the result into your R environment within
seconds.</p>
<p>We can try with a sample pdf from the CIA’s Freedom of Information
Act Electronic Reading Room:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/getwd.html" class="external-link">setwd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempdir</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/download.file.html" class="external-link">download.file</a></span><span class="op">(</span><span class="st">"https://www.cia.gov/readingroom/docs/AGH%2C%20LASLO_0011.pdf"</span>, </span>
<span>              destfile <span class="op">=</span> <span class="st">"CIA.pdf"</span>, </span>
<span>              mode <span class="op">=</span> <span class="st">"wb"</span><span class="op">)</span></span></code></pre></div>
<p>We send it to Document AI with <code><a href="../reference/dai_sync.html">dai_sync()</a></code> and store the
HTTP response in an object, for example <code>response</code>.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">response1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dai_sync.html">dai_sync</a></span><span class="op">(</span><span class="st">"CIA.pdf"</span><span class="op">)</span></span></code></pre></div>
<p>Then we extract the text with
<code><a href="../reference/text_from_dai_response.html">text_from_dai_response()</a></code>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">text</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/text_from_dai_response.html">text_from_dai_response</a></span><span class="op">(</span><span class="va">response1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">text</span><span class="op">)</span></span></code></pre></div>
<p>Synchronous processing is very convenient, but has two limitations.
One is that OCR accuracy may be slightly reduced compared with
asynchronous processing, because <code><a href="../reference/dai_sync.html">dai_sync()</a></code> converts the
source file to a lightweight, grayscale image before passing it to DAI.
The other is scaling; If you have a large pdf or many files, it is
usually easier to process them asynchronously.</p>
</div>
<div class="section level3">
<h3 id="asynchronous-processing">Asynchronous processing<a class="anchor" aria-label="anchor" href="#asynchronous-processing"></a>
</h3>
<p>In asynchronous (offline) processing, you don’t send DAI the actual
document, but rather its location on Google Storage so that DAI can
process it “in its own time”. While slower than synchronous OCR, it
allows for batch processing. The <code>daiR</code> function
<code><a href="../reference/dai_async.html">dai_async()</a></code> is vectorized, so you can send multiple files
with a single call. For this vignette, however, we’ll just use a single
document; the same as in the previous example.</p>
<p>The first step is to upload the source file(s) to a Google Storage
bucket where DAI can find it.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://code.markedmondson.me/googleCloudStorageR/" class="external-link">googleCloudStorageR</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_upload.html" class="external-link">gcs_upload</a></span><span class="op">(</span><span class="st">"CIA.pdf"</span><span class="op">)</span></span></code></pre></div>
<p>Let’s check that our file made it safely:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_list_objects.html" class="external-link">gcs_list_objects</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>We’re now ready to send it off to Document AI with
<code>daiR</code>’s workhorse function, <code><a href="../reference/dai_async.html">dai_async()</a></code>, as
follows:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">response2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dai_async.html">dai_async</a></span><span class="op">(</span><span class="st">"CIA.pdf"</span><span class="op">)</span></span></code></pre></div>
<p>A few words about this function. Its core parameter,
<code>files</code>, tells DAI what to process. You can submit either
.pdf, .gif, or .tiff files, and your <code>files</code> vector can
contain a mixture of these three file formats.</p>
<p>You can also specify a <code>dest_folder</code>: the name of the
bucket folder where you want the output. It defaults to the root of the
bucket, but you can specify another subfolder. If the folder does not
exist already, it will be created.</p>
<p>The function also takes a location parameter (<code>loc</code>),
which defaults to “eu” but can be set to “us”. It has nothing to do with
where you are based, but with which of Google’s servers will process
your files. The parameter <code>skip_rev</code> can be ignored by most;
it is for passing selected documents to human review in business
workflows. The remaining parameters default to things that are defined
by your environment variables (provided you followed the recommendations
above).</p>
<p>Back to our processing. If your call returned “status: 200”, it was
accepted by the API. This does not necessarily mean that the processing
was successful, because the API has no way of knowing right away if the
filepaths you provided exist in your bucket. If there were errors in
your filepaths, your HTTP request would get a 200, but your files would
not actually process. They would turn up as empty files in the folder
you provided. So if you see json files of around 70 bytes each in the
destination folder, you know there was something wrong with your
filenames.</p>
<p>You can check the status of a job with <code><a href="../reference/dai_status.html">dai_status()</a></code>.
Just pass the response object from your <code><a href="../reference/dai_async.html">dai_async()</a></code> into
the parentheses, and it will tell you whether the job is finished. It
won’t tell you how much time remains, but in my experience, processing
takes about 5-20 seconds per page.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/dai_status.html">dai_status</a></span><span class="op">(</span><span class="va">response2</span><span class="op">)</span></span></code></pre></div>
<p>When <code><a href="../reference/dai_status.html">dai_status()</a></code> says “SUCCEEDED”, the json output
files are waiting for you in the bucket.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_list_objects.html" class="external-link">gcs_list_objects</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>Output file names look cryptic, but there’s a logic to them, namely:
<code>"&lt;job_number&gt;/&lt;document_number&gt;/&lt;filename&gt;-&lt;shard_number&gt;.json"</code>
Our file will thus take the form
<code>"&lt;job_number&gt;/0/CIA-0.json"</code>, with
<code>&lt;job_number&gt;</code> changing from one processing call to the
next. Let us store the name in a vector for simplicity:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## NOT RUN</span></span>
<span><span class="va">our_file</span> <span class="op">&lt;-</span> <span class="st">"&lt;job_number&gt;/0/CIA-0.json"</span></span></code></pre></div>
<p>Now let’s download it and save it under a simpler name:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_get_object.html" class="external-link">gcs_get_object</a></span><span class="op">(</span><span class="va">our_file</span>, saveToDisk <span class="op">=</span> <span class="st">"CIA.json"</span>, overwrite <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Finally we extract the text using
<code>text_from_dai_file</code>:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">text</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/text_from_dai_file.html">text_from_dai_file</a></span><span class="op">(</span><span class="st">"CIA.json"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">text</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="large-batches">Large batches<a class="anchor" aria-label="anchor" href="#large-batches"></a>
</h2>
<p>Although <code><a href="../reference/dai_async.html">dai_async()</a></code> takes batches of files, it is
constrained by Google’s <a href="https://cloud.google.com/document-ai/quotas" class="external-link">rate limits</a>.
Currently, a <code><a href="../reference/dai_async.html">dai_async()</a></code> call can contain maximum 50 files
(a multi-page pdf counts as one file), and you can not have more than 5
batch requests and 10 000 pages undergoing processing at any one
time.</p>
<p>Therefore, if you’re looking to process a large batch, you need to
spread the <code><a href="../reference/dai_async.html">dai_async()</a></code> calls out over time. The simplest
solution is to make a function that sends files off individually with a
small wait in between. Say we have a vector called
<code>big_batch</code> containing thousands of filenames. First we would
make a function like this:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">process_slowly</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">file</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/dai_async.html">dai_async</a></span><span class="op">(</span><span class="va">file</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">15</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Then we would iterate it over our file vector:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## NOT RUN</span></span>
<span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html" class="external-link">map</a></span><span class="op">(</span><span class="va">big_batch</span>, <span class="va">process_slowly</span><span class="op">)</span></span></code></pre></div>
<p>This will hold up your console for a while, so it may be worth doing
in the background as an RStudio <a href="https://blog.rstudio.com/2019/03/14/rstudio-1-2-jobs/" class="external-link">job</a>.</p>
<p>Finding the optimal wait time for the <code>Sys-sleep()</code> may
require some trial and error. As a rule of thumb, it should approximate
the time it takes for DAI to process <em>one</em> of your files. This,
in turn, depends on the size of the files, for a 100-page pdf will take
a lot longer to process than a single-page one. In my experience, a
10-second interval works fine for a batch of single-page pdfs.
Multi-page pdfs require proportionally more time. If your files vary in
size, calibrate the wait time to the largest file, or you may get 429s
(HTTP code for “rate limit exceeded”) half way through the
iteration.</p>
<p>Although this procedure is relatively slow, it need not add much to
the overall processing time. DAI starts processing the first files it
receives right away, so when your loop ends, DAI will be mostly done
with the OCR as well.</p>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>Note that if you do not have a
<code>GCS_DEFAULT_BUCKET</code> variable in your .Renviron file, you
will need to either set a default bucket for the current session with
<code>gcs_global_bucket("&lt;a bucket name&gt;")</code> or supply a
<code>bucket = "&lt;a bucket name&gt;"</code> parameter explicitly
inside <code><a href="https://cloudyr.github.io/googleCloudStorageR//reference/gcs_upload.html" class="external-link">gcs_upload()</a></code>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Thomas Hegghammer.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
